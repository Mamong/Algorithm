//
//  insert.c
//  Algorithm
//
//  Created by marco on 2019/2/10.
//  Copyright © 2019 flywire. All rights reserved.
//

#include "insert.hpp"

//插入排序包括直接插入排序、折半插入排序、希尔排序
//插入排序基本思想：每一趟将一个待排序元素，按其关键字大小插入到前面已排好序的子序列中的合适位置上，直到全部元素插入完成。

//直接插入排序
//设输入的待排序数据是数组A[1...n]，首先我们认为A[1]是已排好序的。在排序过程中，依次将A[i](i=2...n)从后往前插入到前面已排好序的子数组A[1...i-1]中的合适位置，待所有A[i]插入完毕，数组A中就包含了已排序好的输出序列。和顺序查找类似，为了在查找插入位置的过程中避免数组下标出界，在A[0]处设监视哨。
//算法空间复杂度O(1)。该算法主程序执行n-1次。在正序时，每次循环只需与前一个记录比较1次，不需要移动，总的比较次数为n-1,移动次数为0.
//逆序时每个元素都要和有序序列的每个元素进行比较，总的比较次数为2+...+n（先与第i-1个元素比较一次，再与i-1个元素各比较一次，即对i从2到n求和），总的移动次数为3+...+(n+1)（哨兵一次，挪位i-1次，赋值一次，即对i+1从2到n求和）.
//直接插入算法的时间复杂度为O(n2)。
//稳定性：直接插入是稳定的，因为当i>j,且ki=kj时，本算法将A[i]插入到A[j]后面，是A[i]和A[j]的相对位置保持不变。
//适用性：它既适用于顺序存储的线性表，也适用于链式存储的线性表。链式存储的时候可以从前往后查找指定元素的位置。注意，绝大部分的排序算法都仅适用于顺序存储的线性表。
void directInsertSort(int list[], int n){
    int i,j;
    //依次将下标2到n插入到有序序列
    for (i = 2; i <= n; i++) {
        //当前元素是否小于前驱
        if (list[i]<list[i-1]) {
            //复制哨兵
            list[0] = list[i];
            //有序序列从后往前查找插入位置，并移动
            for (j = i-1; list[j]>list[0]; j--) {
                //向后挪位
                list[j+1]=list[j];
            }
            //多退了一位，复制到插入位置
            list[j+1] = list[0];
        }
    }
}

//折半插入排序
//与直接插入排序的不同之处在于，确定当前元素在有序子数组中的位置时，直接插入排序是采用顺序查找法，而折半插入排序是采用折半查找法，因此它仅适用于顺序存储的线性表。
//直接插入排序中，总是边比较边移动元素，而折半查找排序则将比较和移动分离，即先查找出元素的待插入位置，然后再统一地移动带插入元素位置之后的所有元素。
//折半插入排序仅仅减少了比较次数，为O(nlog2n)。比较次数与初始排列无关，仅取决于序列中的元素个数n。有序或者接近有序时，直接插入排序比折半插入排序比较次数少；元素移动次数和直接插入排序相同，依赖于元素的初始排列。
//时间复杂度为O(n2),是一种稳定的排序方法。
void halfSearchInsertSort(int list[], int n){
    int i,j,low,mid,high;
    for (i = 2; i <= n; i++) {
        //复制哨兵
        list[0] = list[i];
        low = 1;
        high = i-1;
        //折半查找，默认递增有序
        while (low <= high) {
            mid = (low+high)/2;
            //low,high重合时，如果list[mid] > list[0]，要插入位置为mid。反之为mid+1。这两种情况都为low，也等于high+1。
            if (list[mid] > list[0]) {
                high = mid-1;
            }else{
                low = mid+1;
            }
        }
        
        //high此时已经较要插入位置提前了一个，需要加1补回。
        //也可以用low，low正是要插入位置。
        //统一移动元素，空出插入位置
        for (j=i-1; j>=high+1; j--) {
            list[j+1] = list[j];
        }
        //插入操作
        list[high+1] = list[0];
    }
}

//希尔排序
//又叫缩小增量排序，是1959年D·L·Shell提出来的
//如果待排序序列基本有序，直接插入排序的效率可大大提高。另一方面，直接插入算法简单，在n很小时效率也比较高。希尔排序是基于这两点分析，对直接插入排序进行改进的排序算法。
//基本思想：首先取一个小于n的步长d1，把表中元素分成d1个组，所有距离为d1的倍数的元素放在同一组，在各组中进行直接插入排序；然后取第二个步长d2<d1，重复上述步骤，直到所取到的d1=1，即所有元素都在同一组中；由于此时整个表中元素已呈基本有序，最后进行一次直接插入排序，可以很快得到最终结果。
//空间复杂度为O(1)，平均时间复杂度为O(n1.3)，是一种不稳定的排序方法。
//仅适用于顺序储存的线性表
void shellSort1(int list[], int n){
    //前后元素位置增量是dk,不是1
    //r[0]只是暂存单元，不是哨兵，当j<0时，插入位置已找到
    int dk,i,j,k;
    //步长变化
    for (dk=n/2; dk>=1; dk/=2) {
        //按组排序
        for (i=0; i<dk; i++) {
            //间隔为dk的直接插入排序
            for (j=i+dk; j<n; j+=dk) {
                if (list[j]<list[j-dk]) {
                    list[0] = list[j];
                    for (k=j-dk; k>0&&list[0]<list[k]; k-=dk) {
                        list[k+dk]=list[k];
                    }
                    list[k+dk]=list[0];
                }
            }
        }
    }
}

//分组后组内比较转为从下标dk开始的元素进行组内比较
void shellSort2(int list[], int n){
    //前后元素位置增量是dk,不是1
    //r[0]只是暂存单元，不是哨兵，当j<0时，插入位置已找到
    int dk,i,j;
    //步长变化
    for (dk=n/2; dk>=1; dk/=2) {
        //直接插入排序
        for (i=dk+1; i<=n; i++) {
            if (list[i]<list[i-dk]) {
                list[0] = list[i];
                for (j=i-dk; j>0&&list[0]<list[j]; j-=dk) {
                    list[j+dk]=list[j];
                }
                list[j+dk]=list[0];
            }
        }
    }
}

/*
void directInsert(int list[],int n)
{
    //从下标1开始存放数据
    int i,j;
    for (i = 2; i <= n; i++) {
        if (list[i]<list[i-1]) {
            list[0] = list[i];
            for (j = i-1; list[j]>list[0]; j--) {
                list[j+1]=list[j];
            }
            list[j+1]=list[0];
        }
    }
}*/

