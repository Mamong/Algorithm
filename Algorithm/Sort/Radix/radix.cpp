//
//  radix.c
//  Algorithm
//
//  Created by marco on 2019/2/10.
//  Copyright © 2019 flywire. All rights reserved.
//

#include "radix.hpp"

/*基数排序包括基数排序
 基数排序是桶排序的扩展。
//基数排序不是基于比较进行排序的，而是采用多关键字排序思想，借助分配和收集两种操作对单逻辑关键字进行排序。基数排序分为：最高位优先（MSD）和最低位优先（LSD）。最低位优先基数排序的过程是：先按最低位的值对元素进行排序，在此基础上，再按次低位进行排序，以此类推。由低位向高位，没趟都是根据关键字的一位并在前一趟的基础上对所有元素进行排序，直至最高位，则完成了基数排序的整个过程。
 
 Least significant digit（LSD）
 短的关键字被认为是小的，排在前面，然后相同长度的关键字再按照词典顺序或者数字大小等进行排序。比如1，2，3，4，5，6，7，8，9，10，11或者”b, c, d, e, f, g, h, i, j, ba” 。
 
 Most significance digit（MSD）
 直接按照字典的顺序进行排序，对于字符串、单词或者是长度固定的整数排序比较合适。比如：1, 10, 2, 3, 4, 5, 6, 7, 8, 9和 “b, ba, c, d, e, f, g, h, i, j”。
 
//以r为基数的最低位优先基数排序过程：
//假设线性表由节点序列a0...an-1构成，每个节点aj的关键字由d元组（k(d-1,j)...k(0,j)）组成，其中0<=k(i,j)<=r-1(0<=j<n,0<=i<=d-1)。在排序过程中，使用r个队列Q0...Qr-1。排序过程如下：
//对i=0,1,....d-1，依次做一次分配和收集（其实就是依次稳定的排序过程）
//分配：开始时，把Q0...Qr-1各队列置成空队列，然后依次考察线性表中的每个节点aj(j=0...n-1),如果aj的关键字k(i,j)=k，就把aj放进Qk队列中。
//收集：把Q0...Qr-1各队列中的节点依次首尾相接，得到新的节点序列，从而组成新的线性表。
//给定n个d位数和基数r(<=d，此处限制有疑问)，基数排序可以在O(d(n+r))时间内完成排序。其空间复杂度为O(r)，是一种稳定排序方法。
//基数排序需要进行d趟，每一趟分配和收集的时间为O(n+r)，因此总的时间复杂度为O(d(n+r))，与序列初始状态无关。没一趟排序需要借助r个队列，空间复杂度O(r)。基数排序中使用的是队列，相同关键字元素的相对位置不会发生改变，是稳定的排序方法。
 
 https://www.cnblogs.com/ECJTUACM-873284962/p/6935506.html
*/


/*
 * 获取数组a中最大值
 *
 * 参数说明：
 *     a -- 数组
 *     n -- 数组长度
 */
int get_max(int a[], int n)
{
    int i, max;
    
    max = a[0];
    for (i = 1; i < n; i++)
        if (a[i] > max)
            max = a[i];
    return max;
}

/*
 * 对数组按照"某个位数"进行排序(桶排序)
 *
 * 参数说明：
 *     a -- 数组
 *     n -- 数组长度
 *     exp -- 指数。对数组a按照该指数进行排序。
 *
 * 例如，对于数组a={50, 3, 542, 745, 2014, 154, 63, 616}；
 *    (01) 当exp=1表示按照"个位"对数组a进行排序
 *    (02) 当exp=10表示按照"十位"对数组a进行排序
 *    (03) 当exp=100表示按照"百位"对数组a进行排序
 *    ...
 */
void count_sort(int a[], int n, int exp)
{
    int output[n];             // 存储"被排序数据"的临时数组
    int i, buckets[10] = {0};  //10个桶，每个桶只需要一个存储空间，变成了计数排序
    
    // 将数据出现的次数存储在buckets[]中
    for (i = 0; i < n; i++)
        buckets[ (a[i]/exp)%10]++;
    
    // 更改buckets[i]。目的是让更改后的buckets[i]的值，是该数据在output[]中的位置。
    for (i = 1; i < 10; i++)
        buckets[i] += buckets[i - 1];
    
    // 将数据存储到临时数组output[]中
    for (i = n - 1; i >= 0; i--)
    {
        output[buckets[ (a[i]/exp)%10 ] - 1] = a[i];
        buckets[ (a[i]/exp)%10 ]--;
    }
    
    // 将排序好的数据赋值给a[]
    for (i = 0; i < n; i++)
        a[i] = output[i];
}

/*
 * 基数排序
 *
 * 参数说明：
 *     a -- 数组
 *     n -- 数组长度
 */
void radix_sort(int a[], int n)
{
    int exp;    // 指数。当对数组按各位进行排序时，exp=1；按十位进行排序时，exp=10；...
    int max = get_max(a, n);    // 数组a中的最大值
     
    // 从个位开始，对数组a按"指数"进行排序
    for (exp = 1; max/exp > 0; exp *= 10)
        count_sort(a, n, exp);
}
