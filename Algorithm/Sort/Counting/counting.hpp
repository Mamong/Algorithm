//
//  counting.hpp
//  Algorithm
//
//  Created by marco on 2019/3/19.
//  Copyright © 2019 flywire. All rights reserved.
//

#ifndef counting_hpp
#define counting_hpp

#include <stdio.h>



/*
1.计数排序是一种非常快捷的稳定性强的排序方法，时间复杂度O(n+k) ,其中n为要排序的数的个数，k为要排序的数的最大值。计数排序对一定量的整数排序时候的速度非常快，一般快于其他排序算法。但计数排序局限性比较大，只限于对整数进行排序。计数排序是消耗空间复杂度来获取快捷的排序方法，其空间发展度为O（K）同理K为要排序的最大值。
 
 2.计数排序的基本思想为一组数在排序之前先统计这组数中其他数小于这个数的个数，则可以确定这个数的位置。例如要排序的数为 7 4 2 1 5 3 1 5；
 则比7小的有7个数，所有7应该在排序好的数列的第八位，同理3在第四位，对于重复的数字，1在1位和2位（暂且认为第一个1比第二个1小），5和1一样位于6位和7位。
 
 3.计数排序的实现办法：
 
 　　首先需要三个数组，第一个数组A记录要排序的数列，大小为n，第二个数组B要记录比某个数小的其他数字的个数，所以第二个数组的大小应当为K（数列中最大数的大小），第三个数组C为记录排序好了的数列的数组，大小应当为n。
 
 　　接着需要确定数组最大值并确定B数组的大小。并对每个数由小到大的记录数列中每个数的出现次数。因为是有小到大通过出现次数可以通过前面的所有数的出现次数来确定比这个数小的数的个数，从而确定其位置。
 
 　　对于重复的数，每排好一个数则对其位置数进行减减操作，以此对完成其余相同的数字进行排位。
 */

void CountingSort(int A[], int C[], int len, int k)
{
    int *B = new int[k];
    int i;
    
    //置0
    for (i = 0; i < k; i++)
    {
        B[i] = 0;
    }
    
    //统计个数
    for (i = 0; i < len; i++)
    {
        B[A[i]]++;
    }
    
    //个数转小于等于的个数
    for (i = 1; i < k; i++)
    {
        B[i] += B[i-1];
    }
    
    // 从右至左保证算法的稳定性
    //a中的数在B中查询有i个小于等于它的数（包括自身），那么它应放在C中i-1的位置。
    for (i = len-1; i >=0; i--)
    {
        C[B[A[i]]-1] = A[i];
        B[A[i]]--;
    }
}

#endif /* counting_hpp */
