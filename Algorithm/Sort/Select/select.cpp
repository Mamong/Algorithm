//
//  select.c
//  Algorithm
//
//  Created by marco on 2019/2/10.
//  Copyright © 2019 flywire. All rights reserved.
//

#include "select.hpp"
#include "common.hpp"

//选择排序包括简单选择排序、堆排序
//选择排序的思想是，每一趟（例如第i趟）在后面n-i+1（i=1,2...n-1）个待排序元素中选出最小的元素，作为有序序列的第i个元素，共需进行n-1趟。

//简单选择排序
//简单选择排序的思路就是将最小元素找出并放在序列最前面，在剩下的元素中继续找出最小元素放在第二个位置上，依次类推，每次选出一个元素，即可确定其在有序序列中的最终位置。
//共需选择n-1趟，第i趟选择最小元素需要比较n-i次，总的比较次数n(n-1)/2。序列有序时，移动次数为0；序列逆序时，每趟需要进行1次交换，移动次数3(n-1)。
//时间复杂度O(n2),空间复杂度O(1)。是一种不稳定排序方法。
void simpleSelectSort(int list[], int n)
{
    int min = 0;
    //需要进行n-1趟
    for (int i = 0; i < n-1; i++) {
        min = i;//记录最小元素位置
        for (int j = i+1; j < n; j++) {//在list[i...n-1]中选择最小的元素
            if (list[j]<list[min]) {   //更新最小元素位置
                min = j;
            }
        }
        if (min != i) {               //与第i个元素交换
            swap(list[i], list[min]);
        }
    }
}

//堆排序
/*
 堆排序是一种树形选择排序算法。
 在排序过程中将L[1...n]看成是一棵完全二叉树的顺序存储，
 利用完全二叉树中双亲结点和孩子结点之间的内在关系，在当前无序区中选择关键字最大（最小）的元素。
 
 堆的定义：n个关键字序列L(1...n)成为堆，当且仅当L(i)<=L(2i)且L(i)<=L(2i+1)或L(i)>=L(2i)且L(i)>=L(2i+1)，前者称为小根堆，后者称为大根堆。显然对于大根堆，最大元素存在根节点中，且对其任一非根结点，它的值都小于等于其双亲结点。小根堆正好相反。堆排序常用来实现优先级队列，优先级队列在操作系统的作业调度和其他领域有广泛的应用。
 
 堆排序的关键是构造初始堆，是一个反复筛选的过程。n个结点的完全二叉树，最后一个结点是第[n/2]个结点的孩子。对第[n/2]个结点为根的子树筛选（对于大根堆，若根节点的关键字小于左右孩子中关键字较大者，则交换），
 使该子树成为堆。之后向前依次对各节点（[n/2-1...1]）为根的子树进行筛选。
 筛选后，可能会破坏下一级的堆，于是继续采用上述方法构造下一级的堆，直到以该节点为根的子树构成堆为止。
 */

void AdjustDown(int A[],int k,int len);

void buildMaxHeap(int A[],int len){
    //从i=[n/2]...1反复调整堆
    for (int i = len/2; i>0; i--) {
        AdjustDown(A,i,len);
    }
}

//将元素k向下进行调整
//向下调整的时间与树高h有关，大部分结点树高较小。可证明元素个数为n的序列上建堆，其时间复杂度为O(n)。
void AdjustDown(int A[],int k,int len){
    A[0]=A[k];//暂存
    //沿key较大的子节点向下筛选
    for (int i = 2*k; i<=len; i*=2) {
        //取key较大子节点下标
        if (i<len&&A[i]<A[i+1]) {
            i=1+1;
        }
        //筛选结束
        if (A[0]>=A[i]) {
            break;
        }else{
            //将较大子节点调整到双亲结点
            A[k]=A[i];
            //修改k，以便继续向下筛选
            k=i;
        }
    }
    //将被筛选结点放入最终位置
    A[k]=A[0];
}

//建堆完成后，堆顶元素就是最大值。输出堆顶元素后，通常将堆底元素送入堆顶，此时根节点已不满足大顶堆性质，堆被破坏，将堆顶元素向下调整使其继续保持大顶堆的性质，再输出堆顶元素。如此反复，直到堆中仅剩一个元素为止。
//从输出来看，方便起见，从小到大排序使用大根堆，从大到小排序使用小根堆
//空间复杂度O(1)，
//时间复杂度，建堆O(n),之后有n-1次向下调整操作，每次调整时间复杂度O(h),因此最好、最坏、平均情况下，时间复杂度为O(nlogn)
//是一种不稳定的排序
void HeapSort(int A[],int len){
    //初始建堆
    buildMaxHeap(A, len);
    for (int i = len; i > 1; i --) {
        //输出堆顶元素（和堆底元素交换）
        swap(A[i], A[1]);
        //整理，把剩下的i-1个元素整理成堆
        AdjustDown(A, 1, i-1);
    }
}

//堆的插入和删除
/*
 堆中每次都只能删除堆顶元素。删除堆顶元素时，先将堆的最后一个元素与堆顶元素交换，再对根节点进行向下调整操作。
 对堆进行插入操作时，先将新节点放在堆的末端，再对这个新节点进行向上调整操作。
 */
void AdjustUp(int A[],int k){
    //k既是向上调整的节点，也是堆的元素个数
    A[0] = A[k];
    int i = k/2;
    while (i>0&&A[i]<A[0]) {
        //双亲下调
        A[k]=A[i];
        //记录空出来的位置，并找到其父节点
        k=i;
        i=k/2;
    }
    A[k]=A[0];
}

//Top K算法
/*
 问题描述：有N(N>>10000)个整数,求出其中的前K个最大的数。（称作Top k或者Top 10）
 
 　　问题分析：由于(1)输入的大量数据；(2)只要前K个，对整个输入数据的保存和排序是相当的不可取的。
 
 　　可以利用数据结构的最小堆来处理该问题。
 
 　　　　　　　 最小堆，对于每个非叶子节点的数值，一定不大于孩子节点的数值。这样可用含有K个节点的最小堆来保存K个目前的最大值(当然根节点是其中的最小数值)。
 
 　　每次有数据输入的时候可以先与根节点比较。若不大于根节点，则舍弃；否则用新数值替换根节点数值。并进行最小堆的调整。
 
 同理，求其中的前K个最小的数，可以构造大顶堆。对于每个非叶子节点的数值，一定不小于孩子节点的数值。这样可用含有K个节点的最大堆来保存K个目前的最小值(当然根节点是其中的最大数值)。
 每次有数据输入的时候可以先与根节点比较。若大于根节点，则舍弃；否则用新数值替换根节点数值。并进行最大堆的调整。

 
  　　由于仅仅保存了K个数据，有调整最小堆的时间复杂度为O(logK)，因此TOp K算法(问题)时间复杂度为O(nlogK).
 */
